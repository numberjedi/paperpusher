#include "gui.h"
#include "../parser.h"
#include "../search.h"
#include "glib-object.h"
#include "glibconfig.h"
#include "gui/pdf_viewer.h"
#include "pango/pango-layout.h"
#include <gdk/gdkkeysyms.h>
#include <gtk/gtk.h>
#include <gtk/gtkdnd.h> // drag and drop
#include <pango/pango.h>
//#include "../serializer.h"  // for cache functions if needed
//#include "../loader.h"      // for PaperDatabase
#include <cjson/cJSON.h>
#include <gio/gio.h>
#include <glib.h>
#include <limits.h> // for PATH_MAX
#include <stdio.h>
#include <unistd.h> // for readlink

static PaperDatabase* s_db;
// static InvertedIndex *s_idx;  // if/when you switch to an index

// Widgets (global for simplicity; you can group these in a struct)
static GtkEntry* search_entry;
static GtkListBox* results_list;
static GtkLabel* pdf_preview;

// Forward declarations
static void
on_search_changed(GtkEntry* entry, gpointer _);
static void
on_results_row_selected(GtkListBox* box, GtkListBoxRow* row, gpointer _);
static gboolean
on_key_press(GtkWidget* widget, GdkEventKey* event, gpointer user_data);
static void
on_pdf_dropped(GtkWidget* widget,
               GdkDragContext* context,
               gint x,
               gint y,
               GtkSelectionData* selection_data,
               guint info,
               guint time,
               gpointer user_data);
static void
parser_task(GTask* task,
            gpointer source_object,
            gpointer task_data,
            GCancellable* cancellable);
static void
parser_ready(GObject* source_object, GAsyncResult* res, gpointer user_data);
static GtkListBoxRow*
get_adjacent_row(GtkListBox* box, GtkListBoxRow* row, gboolean next);
static void
navigate(GtkListBox* box, gboolean next);

static gchar*
sanitize_label_text(const char* orig)
{
    if (!orig)
        return g_strdup("");
    if (g_utf8_validate(orig, -1, NULL))
        return g_strdup(orig);
    else
        return g_utf8_make_valid(orig, -1);
}

static void
on_search_changed(GtkEntry* entry, gpointer _)
{
    const char* q = gtk_entry_get_text(entry);
    const Paper* results[MAX_RESULTS];
    int found =
      search_papers(s_db->papers, s_db->count, q, results, MAX_RESULTS);

    // unselect everything so we don't hold a dangling row
    gtk_list_box_unselect_all(results_list);

    // clear old rows
    GList* children = gtk_container_get_children(GTK_CONTAINER(results_list));
    for (GList* c = children; c; c = c->next)
        gtk_widget_destroy(GTK_WIDGET(c->data));
    g_list_free(children);

    // populate new rows
    for (int i = 0; i < found; ++i) {
        Paper* p = results[i];
        GtkWidget* row = gtk_list_box_row_new(); // create row

        // vbox
        GtkWidget* vbox =
          gtk_box_new(GTK_ORIENTATION_VERTICAL, 2); // title & author-year hbox
        gtk_container_add(GTK_CONTAINER(row), vbox);

        // title
        gchar* safe_title = sanitize_label_text(p->title);
        GtkWidget* title = gtk_label_new(safe_title);  // create label
        g_free(safe_title); // free the dup
        gtk_label_set_xalign(GTK_LABEL(title), 0.0); // left-align title
        gtk_label_set_ellipsize(GTK_LABEL(title), PANGO_ELLIPSIZE_END);
        gtk_widget_set_hexpand(
          title, TRUE); // should already be set in glade, but heck
        gtk_box_pack_start(GTK_BOX(vbox), title, FALSE, TRUE, 0);

        // hbox
        GtkWidget* hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 4);
        gtk_widget_set_hexpand(hbox, TRUE);
        gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

        // authors
        GString* safe_authors_string = g_string_new(NULL);
        for (int j = 0; j < p->authors_count; j++) {
            gchar* safe_author = sanitize_label_text(p->authors[j]);
            g_string_append(safe_authors_string, safe_author);
            g_free(safe_author); // free the dup
        }
        GtkWidget* authors = gtk_label_new(safe_authors_string->str);
        gtk_label_set_xalign(GTK_LABEL(authors), 0.0);
        gtk_label_set_ellipsize(GTK_LABEL(authors), PANGO_ELLIPSIZE_END);
        // gtk_widget_set_hexpand(authors, TRUE);  // takes all extra space
        gtk_box_pack_start(GTK_BOX(hbox), authors, FALSE, FALSE, 0);
        g_string_free(safe_authors_string, TRUE); // free the dup

        // year
        char yearbuf[16];
        snprintf(yearbuf, sizeof(yearbuf), "(%d)", p->year);
        GtkWidget* year = gtk_label_new(yearbuf);
        gtk_label_set_xalign(GTK_LABEL(year), 0.0); // right-align year
        gtk_box_pack_start(GTK_BOX(hbox), year, TRUE, TRUE, 0);

        // attach paper pointer
        g_object_set_data(G_OBJECT(row), "paper", p); // store paper on row
        //printf("setting paper title:%s\n", p->title);

        // insert into list
        gtk_list_box_insert(results_list, row, -1); // add row to list
        gtk_widget_show_all(row);
    }

    // select the first row by default (if any)
    if (found > 0) {
        GtkListBoxRow* first = gtk_list_box_get_row_at_index(results_list, 0);
        gtk_list_box_select_row(results_list, first);
    }
    gtk_widget_show_all(GTK_WIDGET(results_list));
}

static void
on_results_row_selected(GtkListBox* box, GtkListBoxRow* row, gpointer _)
{
    if (row == NULL) {
        //gtk_label_set_text(GTK_LABEL(pdf_preview), "Select a paper to preview");
        pdf_viewer_load(NULL);
        return;
    }

    Paper* p = g_object_get_data(G_OBJECT(row), "paper");
    //printf("paper title: %s\n", p->title);
    //gtk_label_set_text(pdf_preview, p->title);
    pdf_viewer_load(p->pdf_file);
}

static GtkListBoxRow*
get_adjacent_row(GtkListBox* box, GtkListBoxRow* row, gboolean next);
static void
navigate(GtkListBox* box, gboolean next);

// Helper: find the next or previous row in the list
static GtkListBoxRow*
get_adjacent_row(GtkListBox* box, GtkListBoxRow* row, gboolean next)
{
    GList* children = gtk_container_get_children(GTK_CONTAINER(box));
    GtkListBoxRow* res = NULL;
    if (!row) {
        // No current selection: pick the first (or last if prev)
        if (children) {
            if (next)
                res = GTK_LIST_BOX_ROW(children->data);
            else {
                GList* last = g_list_last(children);
                res = GTK_LIST_BOX_ROW(last->data);
            }
        } 
        //else {
        //    pdf_viewer_load(NULL);
        //}
    } else {
        // Find the row in the list, then pick its sibling
        for (GList* l = children; l; l = l->next) {
            if (l->data == row) {
                if (next && l->next)
                    res = GTK_LIST_BOX_ROW(l->next->data);
                else if (!next && l->prev)
                    res = GTK_LIST_BOX_ROW(l->prev->data);
                break;
            }
        }
    }
    g_list_free(children);
    return res;
}

// Navigate selection up or down
static void
navigate(GtkListBox* box, gboolean next)
{
    GtkListBoxRow* sel = gtk_list_box_get_selected_row(box);
    GtkListBoxRow* adj = get_adjacent_row(box, sel, next);
    if (adj) {
        gtk_list_box_select_row(box, adj);
        // Keep focus in the search entry so typing continues there:
        gtk_widget_grab_focus(GTK_WIDGET(search_entry));
    }
}

// Keyâ€press handler
static gboolean
on_key_press(GtkWidget* widget, GdkEventKey* event, gpointer user_data)
{
    guint key = event->keyval;
    gboolean ctrl = (event->state & GDK_CONTROL_MASK) != 0;

    // Navigation
    if (key == GDK_KEY_Down || (ctrl && key == GDK_KEY_n)) {
        navigate(results_list, TRUE);
        return TRUE; // stop further handling
    }
    if (key == GDK_KEY_Up || (ctrl && key == GDK_KEY_p)) {
        navigate(results_list, FALSE);
        return TRUE;
    }

    // "Open" the PDF placeholder
    //    if (key == GDK_KEY_Return || (ctrl && key == GDK_KEY_y)) {
    //        // Simulate row-activated on the selected row:
    //        GtkListBoxRow *sel = gtk_list_box_get_selected_row(results_list);
    //        if (sel) {
    //            on_results_row_activated(results_list, sel, NULL);
    //        }
    //        return TRUE;
    //    }

    // All other keys: let the entry handle them (typing)
    return FALSE; // propagate to the default handler (the GtkEntry)
}

static void
on_pdf_dropped(GtkWidget* widget,
               GdkDragContext* context,
               gint x,
               gint y,
               GtkSelectionData* selection_data,
               guint info,
               guint time,
               gpointer user_data)
{
    gchar** uris = gtk_selection_data_get_uris(selection_data);
    if (!uris)
        return;

    // update GUI NOW
    // want some 'loading' message
    //gtk_label_set_text(pdf_preview, "Retrieving metadata...");
    //while (gtk_events_pending())
    //    gtk_main_iteration();

    // printf("pdf dropped!\n");
    for (int i = 0; uris && uris[i]; ++i) {
        gchar* path = g_filename_from_uri(uris[i], NULL, NULL);
        // printf("path: %s\n", path);
        if (!path)
            continue;

        GTask* task = g_task_new(NULL, NULL, parser_ready, NULL);
        g_task_set_task_data(task, path, g_free);
        g_task_run_in_thread(task, parser_task);
        g_object_unref(task);
    }

    g_strfreev(uris);
    gtk_drag_finish(context, TRUE, FALSE, time);
}

// background parser thread
static void
parser_task(GTask* task,
            gpointer source_object,
            gpointer task_data,
            GCancellable* cancellable)
{

    gchar* path = task_data;
    GError* err = NULL;
    Paper* p = parser_run(s_db, path, &err);
    if (!p) {
        g_task_return_error(task, err);
    } else {
        g_task_return_pointer(task, p, NULL);
    }
    // GTask will free on its own
}

// main-loop callback
static void
parser_ready(GObject* source_object, GAsyncResult* result, gpointer user_data)
{

    GError* error = NULL;
    Paper* p = g_task_propagate_pointer(G_TASK(result), &error);
    if (error) {
        //gtk_label_set_text(GTK_LABEL(pdf_preview), error->message);
        g_error_free(error);
    } else {
        // behaviour is still undecided
        //char* out = p->pdf_file;
        //X
        //gtk_label_set_text(pdf_preview, out);
        //g_free(out);
    }
}

void
gui_run(PaperDatabase* db)
{
    s_db = db;

    // 1) load Glade UI
    GtkBuilder* b = gtk_builder_new_from_file("gui/main_window.ui");
    GtkWidget* w = GTK_WIDGET(gtk_builder_get_object(b, "main_window"));
    pdf_viewer_setup(b, "pdf_view");

    // 2) grab widgets
    search_entry = GTK_ENTRY(gtk_builder_get_object(b, "search_entry"));
    results_list = GTK_LIST_BOX(gtk_builder_get_object(b, "results_list"));
    pdf_preview = GTK_LABEL(gtk_builder_get_object(b, "pdf_placeholder"));
    gtk_widget_grab_focus(GTK_WIDGET(search_entry));

    // 3) connect handlers
    g_signal_connect(
      search_entry, "changed", G_CALLBACK(on_search_changed), NULL);
    g_signal_connect(
      results_list, "row-selected", G_CALLBACK(on_results_row_selected), NULL);
    g_signal_connect(w, "key-press-event", G_CALLBACK(on_key_press), NULL);
    g_signal_connect(w, "destroy", G_CALLBACK(gtk_main_quit), NULL);

    // Enable drag-and-drop for PDF files
    GtkTargetEntry target = { "text/uri-list", 0, 0 };
    gtk_drag_dest_set(w, GTK_DEST_DEFAULT_ALL, &target, 1, GDK_ACTION_COPY);
    g_signal_connect(w, "drag-data-received", G_CALLBACK(on_pdf_dropped), NULL);

    // 4) show & run
    gtk_widget_show_all(w);
    gtk_main();
}
