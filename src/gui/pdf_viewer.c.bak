#include "pdf_viewer.h"
#include "gtk/gtk.h"
#include "pango/pango-layout.h"
#include "pango/pangocairo.h"
#include <glib.h>
#include <gio/gio.h>
#include <poppler.h>

struct _PdfViewer {
    PopplerDocument *doc;
    PopplerPage     *page;
    GtkWidget       *drawing_area;
};

// Global handle for the viewer instance
static PdfViewer *g_pdf_viewer = NULL;

// Draw callback
static gboolean
on_pdf_draw(GtkWidget *widget, cairo_t *cr, gpointer user_data)
{
    PdfViewer *viewer = (PdfViewer*)user_data;

    // paint theme background
    GtkStyleContext *ctx = gtk_widget_get_style_context(widget);
    GtkAllocation    alloc;
    gtk_widget_get_allocation(widget, &alloc);
    gtk_render_background(ctx, cr,
                          alloc.x, alloc.y,
                          alloc.width, alloc.height);

    // if no page draw placeholder
    if (!viewer || !viewer->page) {
        const char* msg = "Select a PDF to preview it";
        PangoLayout* layout = gtk_widget_create_pango_layout(widget, msg);
        int lw, lh;
        pango_layout_get_size(layout, &lw, &lh);
        lw /= PANGO_SCALE; lh /= PANGO_SCALE;
        cairo_move_to(cr,
                      (alloc.width - lw) / 2,
                      (alloc.height - lh) /2);
        pango_cairo_show_layout(cr, layout);
        g_object_unref(layout);
        return FALSE;
    }

    cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);
    cairo_paint(cr);

    // Get widget size to scale PDF
    double pw, ph;
    poppler_page_get_size(viewer->page, &pw, &ph);
    double scale = MIN((double)alloc.width / pw,
                       (double)alloc.height / ph);

    cairo_save(cr);
    cairo_scale(cr, scale, scale);
    poppler_page_render(viewer->page, cr);
    cairo_restore(cr);

    return FALSE;
}

void
pdf_viewer_setup(GtkBuilder *builder, const char *drawing_area_id)
{
    GtkWidget *area = GTK_WIDGET(
        gtk_builder_get_object(builder, drawing_area_id)
    );
    g_return_if_fail(GTK_IS_DRAWING_AREA(area));

    // Allocate the viewer
    g_pdf_viewer = g_new0(PdfViewer, 1);
    g_pdf_viewer->doc          = NULL;
    g_pdf_viewer->page         = NULL;
    g_pdf_viewer->drawing_area = area;

    // Store on widget and connect draw
    g_object_set_data(G_OBJECT(area), "pdf_viewer", g_pdf_viewer);
    g_signal_connect(area,
                     "draw",
                     G_CALLBACK(on_pdf_draw),
                     g_pdf_viewer);
}

PdfViewer *
pdf_viewer_get(GtkWidget *drawing_area)
{
    return (PdfViewer*)g_object_get_data(
        G_OBJECT(drawing_area), "pdf_viewer"
    );
}

void
pdf_viewer_load(const char *filepath)
{
    if (!g_pdf_viewer)
        return;

    // Clean up previous doc/page
    if (g_pdf_viewer->page) {
        g_object_unref(g_pdf_viewer->page);
        g_pdf_viewer->page = NULL;
    }
    if (g_pdf_viewer->doc) {
        g_object_unref(g_pdf_viewer->doc);
        g_pdf_viewer->doc = NULL;
    }

    if (!filepath) {
        // Nothing to show. Force a redraw so the area goes back to theme color
        gtk_widget_queue_draw(g_pdf_viewer->drawing_area);
        return;
    }

    GError *error = NULL;
    gchar *uri = g_filename_to_uri(filepath, NULL, &error);
    if (!uri) {
        g_warning("Invalid file path: %s", filepath);
        return;
    }

    g_pdf_viewer->doc = poppler_document_new_from_file(uri, NULL, &error);
    g_free(uri);

    if (!g_pdf_viewer->doc) {
        g_warning("Failed to open PDF '%s': %s",
                  filepath,
                  error ? error->message : "<unknown>");
        g_clear_error(&error);
        return;
    }

    // Load first page
    g_pdf_viewer->page = poppler_document_get_page(g_pdf_viewer->doc, 0);
    if (!g_pdf_viewer->page) {
        g_warning("PDF '%s' has no pages", filepath);
        g_object_unref(g_pdf_viewer->doc);
        g_pdf_viewer->doc = NULL;
    }

    // Redraw
    gtk_widget_queue_draw(g_pdf_viewer->drawing_area);
}

